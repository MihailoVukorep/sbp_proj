QUERY OPTIMIZATION DOCUMENTATION

================================================================================
QUERY 1: Average revenue per company (budget > 50M)
================================================================================

Problem identification:
- Budget filter: Full collection scan without index (O(n))
- Companies: Array unwind causing multiple document processing
- Aggregation: Multiple stages without optimization
- Memory: Intermediate results accumulate during processing

Solution applied:
- Computed field: budget_category (computed during insert)
  * 'low': budget < 10M
  * 'medium': 10M <= budget < 50M
  * 'high': 50M <= budget < 100M
  * 'blockbuster': budget >= 100M

- Index: (financial.budget_category, production.companies)
  * Supports range filtering on category
  * Supports unwind grouping
  * B-tree ordering enables sorted access

- Pipeline optimization:
  * $match stage uses index to filter only relevant documents
  * $unwind operates on much smaller dataset
  * $group benefits from sorted input
  * Final $sort uses index ordering

Expected improvement: 70-85%

Query execution flow:
1. Initiate index range scan for budget_category IN ['high', 'blockbuster']
2. For each qualifying document, unwind companies array
3. Group by company ID (in-memory aggregation)
4. Calculate average revenue for each group
5. Sort and limit results


================================================================================
QUERY 2: Average rating per genre by decade
================================================================================

Problem identification:
- Decade calculation: Integer arithmetic in every stage
- Nested structure: release_info.release_date.year (3 levels)
- Genre unwind: Array processing without index support
- Double grouping: Group by (decade, genre) combination

Solution applied:
- Computed field: decade = (year // 10) * 10
  * Calculated once during insert
  * Stored at release_info level (2 levels instead of 3)
  * Eliminates $floor, $divide operations from pipeline

- Index: (release_info.decade, content_info.genres, ratings.vote_average)
  * Supports filtering by decade
  * Supports grouping by genres (multikey)
  * Includes vote_average for aggregation

- Schema denormalization:
  * release_info.year: Direct access (was in nested release_date)
  * release_info.month: Direct access
  * release_info.decade: New computed field

Expected improvement: 75-90%

Query execution flow:
1. Index range scan for decade values
2. Filter documents with vote_average > 0
3. Unwind genres array (covered by multikey index)
4. In-memory grouping by (decade, genre)
5. Calculate average rating per group
6. Sort results (already partially ordered by index)


================================================================================
QUERY 3: Months with most blockbuster movies
================================================================================

Problem identification:
- Budget range: Range query (> 100M) without index requires full scan
- Month extraction: Nested date structure (release_info.release_date.month)
- Implicit calculation: Determining blockbuster status in every scan

Solution applied:
- Computed field: budget_category = 'blockbuster' when budget >= 100M
  * Boolean categorical lookup (O(1)) vs range comparison (O(n))
  * Pre-computed eliminates runtime decision logic
  * Can be used across multiple queries

- Schema denormalization:
  * release_info.month: Direct access (was 3 levels deep)
  * Reduces B-tree traversal depth
  * Smaller average document size

- Index: (financial.budget_category, release_info.month)
  * Supports budget category filtering
  * Supports grouping by month
  * Both operations use index order

Expected improvement: 80-90%

Query execution flow:
1. Index lookup for budget_category = 'blockbuster'
2. Filter documents with month != null
3. Group by month (12 buckets maximum)
4. Calculate count and revenue aggregates
5. Sort by count descending (already available from aggregation)


================================================================================
QUERY 4: Most profitable genre combinations
================================================================================

Problem identification:
- Genre pairs: Expensive nested loop in aggregation pipeline
  * For N genres: N(N-1)/2 pairs generated at runtime
  * Cartesian product computation: O(NÂ²) per document
  * Massive memory overhead in large result sets

- Profit/ROI: Calculated in every document during aggregation
- No index: Grouping by computed pairs cannot use indexes
- Multi-stage: Complex pipeline slows execution

Solution applied:
- Precomputed field: genre_pairs (all 2-combinations)
  * Calculated during insert (one time only)
  * Stored as array: ['Action+Drama', 'Action+Sci-Fi', ...]
  * Sorted for consistency and deduplication

- Computed financial fields:
  * profit = revenue - budget (eliminates subtraction in pipeline)
  * roi = ((revenue - budget) / budget) * 100 (eliminates division)
  * is_profitable = profit > 0 (eliminates comparison)

- Index: (content_info.genre_pairs, financial.roi)
  * Multikey index on genre_pairs array
  * Supports grouping by pair
  * Supports sorting by ROI

Expected improvement: 85-95% (highest impact)

Query execution flow:
1. Index scan for is_profitable = true documents
2. Filter for non-empty genre_pairs
3. Unwind genre_pairs (all values pre-calculated)
4. Group by genre pair (pre-calculated aggregates)
5. Filter groups with >= 10 movies
6. Sort by average ROI (index-assisted)


Detailed example:
Movie: {
  genres: ['Action', 'Sci-Fi', 'Thriller'],
  genre_pairs: ['Action+Sci-Fi', 'Action+Thriller', 'Sci-Fi+Thriller']
}

After unwind, yields 3 documents (pre-calculated):
  { genre_pair: 'Action+Sci-Fi', ... }
  { genre_pair: 'Action+Thriller', ... }
  { genre_pair: 'Sci-Fi+Thriller', ... }

Without optimization, pipeline would calculate these pairs for every document.


================================================================================
QUERY 5: Average runtime per country (rating > 7, 100+ movies)
================================================================================

Problem identification:
- Vote average: Range comparison without index (O(n) scan)
- Countries: Array unwind without index support
- Two-pass aggregation: Group then match on count (inefficient)
- Implicit filtering: Determining quality in every scan

Solution applied:
- Computed field: quality_tier categorization
  * 'poor': vote_average < 5.0
  * 'average': 5.0 <= vote_average < 6.0
  * 'good': 6.0 <= vote_average < 7.0
  * 'excellent': vote_average >= 7.0

- Index: (ratings.quality_tier, production.countries, content_info.runtime)
  * Supports categorical filtering
  * Multikey index for countries array
  * Includes runtime for aggregation

- Optimization: Early $match on quality_tier
  * Uses index for fast filtering
  * Reduces documents for unwind operation
  * Reduces memory during grouping

Expected improvement: 70-85%

Query execution flow:
1. Index range scan for quality_tier = 'excellent'
2. Filter documents with runtime > 0
3. Unwind countries array
4. In-memory group by country
5. Count movies per country
6. Filter groups with >= 100 movies (memory operation, already reduced)
7. Calculate average runtime per country
8. Sort by runtime descending


================================================================================
INDEXING STRATEGY SUMMARY
================================================================================

Index types and their purpose:

Single-field indexes:
- idx_budget: Fallback for direct budget queries
- idx_decade: For decade-only filtering
- idx_vote_average: For rating-only queries

Compound indexes:
- Ordered by filter conditions first, then group/sort fields
- Enables covered queries when projection matches index
- Uses leftmost prefix property for flexible queries

Multikey indexes:
- Applied to array fields (genres, countries, genre_pairs)
- One index entry per array element
- Enables efficient $unwind operations

Text index:
- Enables full-text search on title and overview
- Supports phrase queries and fuzzy matching


================================================================================
PERFORMANCE EXPECTATIONS
================================================================================

Query 1: 70-85% faster
Reason: Budget filter becomes O(log n) with index vs O(n) full scan

Query 2: 75-90% faster
Reason: Eliminates $floor and $divide operations from pipeline

Query 3: 80-90% faster
Reason: Categorical lookup faster than range comparison

Query 4: 85-95% faster (most dramatic)
Reason: Genre pairs pre-computed, eliminates expensive algorithm

Query 5: 70-85% faster
Reason: Early index filtering reduces aggregation input size


================================================================================
MAINTENANCE CONSIDERATIONS
================================================================================

Document size impact:
- Original document: ~2-3 KB
- V2 with computed fields: ~2.5-3.5 KB
- Additional storage: 15-25% per document
- Index storage: ~30-40% additional for 14 indexes
- Trade-off: Acceptable for query performance gains

Index maintenance:
- Reindex if fragmentation > 10%
- Monitor index size growth
- Drop unused indexes after query pattern analysis
- Regular index statistics updates

Schema versioning:
- Added schema_version: 2 field for version tracking
- Enables future migrations (v3, v4, etc.)
- Allows coexistence of multiple schema versions
